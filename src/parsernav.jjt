options {
	LOOKAHEAD=1;
}

PARSER_BEGIN(ParserNav)

import java.io.*;
import java.util.*;

public class ParserNav {
	
	public static LinkedList<Path> querries = new LinkedList<Path>();
	
	public static void main(String args[]) throws ParseException, FileNotFoundException {
		
		// checks args
		if(args.length != 1){
			System.out.println("Incorrect arguments, correct use:");
			System.out.println("ParserNav <path of file to be compiled>");
			System.exit(-1);
		}
		
		FileInputStream fis = new FileInputStream(new File(args[0]));
		
		ParserNav parserNav = new ParserNav(fis);
		SimpleNode root = parserNav.ParseExpression();
		
		System.out.println("\n\nAST:\n");
		root.dump("");
		System.out.println("\n--------");
		
		exportToFile(args[0]);
	}
	
	public static void exportToFile(String filePath){
		System.out.println("Exporting To File");
		
		int index = filePath.lastIndexOf(".");
		String exportFile = filePath.substring(0, index);
		exportFile += "_output";
		exportFile += filePath.substring(index, filePath.length());
		
		while(!querries.isEmpty()){
			System.out.println((To) querries.remove());
		}
	}
}

PARSER_END(ParserNav)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

TOKEN :
{
	< COMMA: "," >
|	< SEMICOLON: ( ";" ) >
|	< SRC: ( "src" ) >
|	< DEST: ( "dest" ) >
|	< FIND: ( "find" ) >
|	< CYCLE: ( "cycle" ) >
|	< SIMPLECYCLE: ( "simplecycle" ) >
|	< NOT: ( "not" ) >
|	< PASS: ( "pass" ) >
|	< LENGTH: ( "length" ) >
|	< NEAREST: ( "nearest" ) >
|	< MAXIMIZE: ( "maximize" ) >
|	< MINIMIZE: ( "minimize" ) >
|	< VAR: ["A"-"Z","a"-"z"](["0"-"9","A"-"Z","a"-"z"])* >
|	< INT: (["0"-"9"])+>
}

SimpleNode ParseExpression() #Parse: {Path obj;} {
	obj=StartNode() <SEMICOLON>
	{
		querries.add(obj);
	}
	( <EOF> | ParseExpression() )
	{
		return jjtThis;
	}
}

Path StartNode() #void: {Token t; Path obj;} {
	<SRC> t=<VAR>
	obj=Path(t)
	{
		return obj;
	}
}

To Path(Token t) #To: {To obj;} {
	{
		obj = new To();
		obj.sourceNodeName = t.image;
	}
	DestNode(obj) PathCriteria(obj)
	{
		return obj;
	}
}

void DestNode(To obj) #void: {Token t;} {
	<DEST> t=<VAR>
	{
		obj.destNodeName = t.image;
	}
}

void PathCriteria(To obj) #void: {} {
	OptimalCriteria(obj) (RestrictionPath(obj))?
}

void OptimalCriteria(To obj) #void: {} {
	( <MINIMIZE>
	{
		obj.toMinimize = true;
	}
	| <MAXIMIZE>
	{
		obj.toMinimize = false;
	}
	) Property(obj) 
}

void Property(To obj) #void: {Token t;} {
	t=<VAR>
	{
		obj.attributeFocus = t.image;
	}
}

void RestrictionPath(To obj) #void: {} {
	{
		obj.usePassingRestriction = true;
	}
	(<NOT>
	{
		obj.toPass = false;
	}
	)? <PASS>	RestrictionPathParam(obj)
}

void RestrictionPathParam(To obj) #void: {Token t;} {
	t=<VAR>
	{
		obj.restrictionPathNodes.add(t.image);
	}
	(<COMMA> RestrictionPathParam(obj))?
}