options {
	LOOKAHEAD=1;
	static=false;
}

PARSER_BEGIN(ParserNav)

import java.io.*;
import java.util.*;
public class ParserNav{
	
	public static void main(String args[]) throws ParseException {
		SimpleNode root = null;
		if(args.length==0) {
			System.out.println("\nParser waiting");
			System.out.print("\nString -> ");

			ParserNav pNav = new ParserNav(System.in);
			root = pNav.ParseExpression();

			System.out.println(" --> Aceite\n\n");
			System.out.println("\n-----");

			System.out.println("AST:\n");
			root.dump("");
			System.out.println("\n-----");
		}else {
			for(String s : args) {
			  try{			    
				BufferedReader rd=new BufferedReader(new FileReader(s));
				ParserNav pNav = new ParserNav(rd);
				root = pNav.ParseExpression();
	
				System.out.println("\n-----");
				System.out.println("AST:\n");
				root.dump("");
				System.out.println("\n-----");
				
			  } catch(FileNotFoundException e){
			    System.out.println("File:"+s+" not found");
			    continue;			  }
			}
		}
		
		if(root != null){
			System.out.println("\n-----");
			System.out.println("CypherQuerry:\n");
			String str = generateCypherQuery(root);
			System.out.println(str);
			System.out.println("\n\n-----");
		}
	}
	
	public static String generateCypherQuery(SimpleNode node){	
		if(node.jjtGetNumChildren() == 0) // leaf node
			return (String) node.value;
		
		String holder = "";
		for(int i = 0; i < node.jjtGetNumChildren(); i++)
			holder += "||" + generateCypherQuery((SimpleNode) node.jjtGetChild(i));
		
		return holder;
	}
}

PARSER_END(ParserNav)

SKIP : {
	<"/*"> : DSL_MODE // TODO: move state change to token manager? how?
	| <~[]> // ignores tokens
}

<DSL_MODE> SKIP : {
	<"*/"> : DEFAULT
	|
	<" "> | <"\r"> | <"\t">
}

<DSL_MODE> TOKEN : {
	< COMMA: "," >
	|
	< SRC: ( "src" ) >
	|
	< DEST: ( "dest" ) >
	|
	< FIND: ( "find" ) >
	|
	< CYCLE: ( "cycle" ) >
	|
	< SIMPLECYCLE: ( "simplecycle" ) >
	|
	< NOT: ( "not" ) >
	|
	< PASS: ( "pass" ) >
	|
	< LENGTH: ( "length" ) >
	|
	< SHORTEST: ( "shortest" ) >
	|
	< CHEAPEST: ( "cheapest" ) >
	|
	< NEAREST: ( "nearest" ) >
	|
	< MAXIMIZE: ( "maximize" ) >
	|
	< MINIMIZE: ( "minimize" ) >
	|
	< VAR: ["A"-"Z","a"-"z"](["0"-"9","A"-"Z","a"-"z"])* >
	|
	< INT: (["0"-"9"])+>
}

SimpleNode ParseExpression() #Parse: {} {
	StartNode() ( Path() | Find() | Cycle() | SimpleCycle() )
	<EOF> {return jjtThis;}
}

void StartNode() #Source: {Token t;} {
	<SRC> t=<VAR>{
		jjtThis.value = t.image;
	}
}

void DestNode() #Dest: {Token t;} {
	<DEST> t=<VAR>{
		jjtThis.value = t.image;
	}
}

void Path() #To: {} {
	DestNode() PathCriteria()
}

void Find() #Find: {} {
	<FIND> FindCriteria()
}

void Cycle() #Cycle: {} {
	<CYCLE> CycleCriteria()
}

void SimpleCycle() #SimpleCycle: {} {
	<SIMPLECYCLE> CycleCriteria()
}

void PathCriteria() #Criteria: {} {
	(GraphCriteria() |  OptimalCriteria()) (Amount())? (RestrictionPath())?
}

void FindCriteria() #FindCriteria: {} {
	<NEAREST> (Amount())? (RestrictionPath())?
}

void CycleCriteria() #CycleCriteria: {} {
	Length() (  (GraphCriteria() |  OptimalCriteria()) (Amount())? (RestrictionPath())?  )?
}

void GraphCriteria() #void: {} {
	<SHORTEST> #Shortest
	|
	<CHEAPEST> #Cheapest
}

void OptimalCriteria() #void: {} {
	<MAXIMIZE> #Maximize Property() 
	|
	<MINIMIZE> #Minimize Property() 
}

void RestrictionPath() #RestrictPath: {} {
	(<NOT>)? <PASS> RestrictionPathParam()
}

void RestrictionPathParam() #Restriction: {Token t;} {
	t=<VAR> {
		jjtThis.value = t.image;
	}(<COMMA> RestrictionPathParam())*
}

void Amount() #Amount: {Token t;} {
	t=<INT> {
		jjtThis.value = t.image;
	}
}

void Property() #Property: {Token t;} {
	t=<VAR> {
		jjtThis.value = t.image;
	}
}

void Length() #Length: {Token t;} {
	<LENGTH> t=<INT> {
		jjtThis.value = t.image;
	}
}