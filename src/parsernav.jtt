options {
	LOOKAHEAD=1;
}

PARSER_BEGIN(ParserNav)

public class ParserNav
{
	public static void main(String args[]) throws ParseException {
		System.out.println("\nParser waiting");
		System.out.print("\nString -> ");

		ParserNav pNav = new ParserNav(System.in);
		SimpleNode root = pNav.ParseExpression();
		
		System.out.println(" --> Aceite\n\n");
		
		System.out.println("AST:\n");
		root.dump("");
		System.out.println("\n-----");
	}
}

PARSER_END(ParserNav)

SKIP : {
	" " | "\r" | "\t"
}

TOKEN : {
	< SRC: ( "src" ) >
	|
	< DEST: ( "dest" ) >
	|
	< FIND: ( "find" ) >
	|
	< CYCLE: ( "cycle" ) >
	|
	< SIMPLECYCLE: ( "simplecycle" ) >
	|
	< NL: "\n" >
	|
	< COMMA: "," >
	|
	< NOT: ( "not" ) >
	|
	< PASS: ( "pass" ) >
	|
	< LENGTH: ( "length" ) >
	|
	< SHORTEST: ( "shortest" ) >
	|
	< CHEAPEST: ( "cheapest" ) >
	|
	< FASTEST: ( "fastest" ) >
	|
	< NEAREST: ( "nearest" ) >
	|
	< NODE: ["A"-"Z","a"-"z"](["0"-"9","A"-"Z","a"-"z"])* >
	|
	< INT: (["0"-"9"])+>
	|
	< PROPRIETY: ["A"-"Z","a"-"z"](["0"-"9","A"-"Z","a"-"z"])* >
}

SimpleNode ParseExpression() #Parse: {} {
	StartNode() ( Path() | Find() | Cycle() | SimpleCycle() ) <NL> {return jjtThis;}
}

void StartNode() #SourceNode: {} {
	<SRC> <NODE>
}

void Path() #path: {} {
	DestNode() Criteria() (Amount())? (RestrictionPath())?
}

void DestNode() #DestNode: {} {
	<DEST> <NODE>
}

void RestrictionPath() #restrictionpath: {} {
	(<NOT>)? <PASS> RestrictionPathParam()
}

void RestrictionPathParam() #restrictionpathparam: {} {
	<NODE> (<COMMA> <NODE>)*
	|
	<PROPRIETY>
}

void Find() #find: {} {
	<FIND> Criteria()
}

void Cycle() #cycle: {} {
	<CYCLE> CycleCriteria()
}

void SimpleCycle() #simplecycle: {} {
	<SIMPLECYCLE> CycleCriteria()
}

void CycleCriteria() #cyclecriteria: {} {
	Length() Criteria()
}

void Length() #length: {} {
	<LENGTH> <INT>
}

void Criteria() #criteria: {} {
	<SHORTEST>
	|
	<CHEAPEST>
	|
	<FASTEST>
	|
	<NEAREST>
}

void Amount() #amount: {} {
	<INT>
}