/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. parsernav.jj */
/*@egen*/options {
	LOOKAHEAD=1;
}

PARSER_BEGIN(ParserNav)

import java.io.*;
import java.util.*;

public class ParserNav/*@bgen(jjtree)*/implements ParserNavTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTParserNavState jjtree = new JJTParserNavState();

/*@egen*/
	
	public static LinkedList<Path> querries = new LinkedList<Path>();
	
	public static void main(String args[]) throws ParseException, IOException {
		
		// checks args
		if(args.length != 1){
			System.out.println("Incorrect arguments, correct use:");
			System.out.println("ParserNav <path of file to be compiled>");
			System.exit(-1);
		}
		
		FileInputStream fis = new FileInputStream(new File(args[0]));
		
		ParserNav parserNav = new ParserNav(fis);
		SimpleNode root = parserNav.ParseExpression();
		
		System.out.println("\n\nAST:\n");
		root.dump("");
		System.out.println("\n--------");
		
		exportToFile(root, args[0]);
	}
	
	public static void exportToFile(SimpleNode root, String filePath) throws IOException{
		System.out.println("Exporting To File\n");
		
		int index = filePath.lastIndexOf(".");
		String exportFile = filePath.substring(0, index);
		exportFile += "_output";
		exportFile += filePath.substring(index, filePath.length());
		
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(exportFile))));
		
		int indexAST = 0;
		while(!querries.isEmpty()){
			Path querry = querries.remove();
			
			switch (((SimpleNode) root.jjtGetChild(indexAST)).id) {
			case ParserNavTreeConstants.JJTTO:
				bw.write(((To) querry).toString());
				bw.newLine();
				bw.newLine();
				
				System.out.println((To) querry);
				System.out.println("\n");
				break;
			case ParserNavTreeConstants.JJTCYCLE:
				bw.write(((Cycle) querry).toString());
				bw.newLine();
				bw.newLine();
				
				System.out.println((Cycle) querry);
				System.out.println("\n");
				break;
			case ParserNavTreeConstants.JJTSIMPLECYCLE:
				bw.write(((Cycle) querry).toString());
				bw.newLine();
				bw.newLine();
				
				System.out.println((Cycle) querry);
				System.out.println("\n");
				break;
			}
			
			indexAST++;
		}
		
		bw.close();
	}
}

PARSER_END(ParserNav)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

TOKEN :
{
	< COMMA: "," >
|	< SEMICOLON: ( ";" ) >
|	< SRC: ( "src" ) >
|	< DEST: ( "dest" ) >
|	< FIND: ( "find" ) >
|	< CYCLE: ( "cycle" ) >
|	< SIMPLECYCLE: ( "simplecycle" ) >
|	< NOT: ( "not" ) >
|	< PASS: ( "pass" ) >
|	< MINLENGTH: ( "minlength" ) >
|	< NEAREST: ( "nearest" ) >
|	< MAXIMIZE: ( "maximize" ) >
|	< MINIMIZE: ( "minimize" ) >
|	< VAR: ["A"-"Z","a"-"z"](["0"-"9","A"-"Z","a"-"z"])* >
|	< INT: (["0"-"9"])+>
}

SimpleNode ParseExpression()       : {/*@bgen(jjtree) Parse */
                                      SimpleNode jjtn000 = new SimpleNode(JJTPARSE);
                                      boolean jjtc000 = true;
                                      jjtree.openNodeScope(jjtn000);
/*@egen*/Path obj;} {/*@bgen(jjtree) Parse */
        try {
/*@egen*/
	ParseExpressionAux()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		return jjtn000;
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ParseExpressionAux()      : {Path obj;} {
	obj=StartNode() <SEMICOLON>
	{
		querries.add(obj);
	}
	( <EOF> | ParseExpressionAux() )
}

Path StartNode()      : {Token t; Path obj;} {
	<SRC> t=<VAR>
	(obj=Path(t) | obj=Cycle(t) )
	{
		return obj;
	}
}

To Path(Token t)    : {/*@bgen(jjtree) To */
                       SimpleNode jjtn000 = new SimpleNode(JJTTO);
                       boolean jjtc000 = true;
                       jjtree.openNodeScope(jjtn000);
/*@egen*/To obj;} {/*@bgen(jjtree) To */
        try {
/*@egen*/
	{
		obj = new To();
		obj.sourceNodeName = t.image;
	}
	DestNode(obj) PathCriteria(obj)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		return obj;
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void DestNode(To obj)      : {Token t;} {
	<DEST> t=<VAR>
	{
		obj.destNodeName = t.image;
	}
}

void PathCriteria(To obj)      : {} {
	OptimalCriteria(obj) (RestrictionPath(obj))?
}

void OptimalCriteria(Path obj)      : {} {
	( <MINIMIZE>
	{
		obj.toMinimize = true;
	}
	| <MAXIMIZE>
	{
		obj.toMinimize = false;
	}
	) Property(obj) 
}

void Property(Path obj)      : {Token t;} {
	t=<VAR>
	{
		obj.attributeFocus = t.image;
	}
}

void RestrictionPath(Path obj)      : {} {
	{
		obj.usePassingRestriction = true;
	}
	(<NOT>
	{
		obj.toPass = false;
	}
	)? <PASS>	RestrictionPathParam(obj)
}

void RestrictionPathParam(Path obj)      : {Token t;} {
	t=<VAR>
	{
		obj.restrictionPathNodes.add(t.image);
	}
	(<COMMA> RestrictionPathParam(obj))?
}

Cycle Cycle(Token t)      : {Cycle obj;} {
	{
		obj = new Cycle();
		obj.sourceNodeName = t.image;
	}
	CycleCondition(obj) CycleCriteria(obj)
	{
		return obj;
	}
}

void CycleCondition(Cycle obj)      : {} {
	(/*@bgen(jjtree) Cycle */
          {
            SimpleNode jjtn001 = new SimpleNode(JJTCYCLE);
            boolean jjtc001 = true;
            jjtree.openNodeScope(jjtn001);
          }
          try {
/*@egen*/ <CYCLE>/*@bgen(jjtree)*/
          } finally {
            if (jjtc001) {
              jjtree.closeNodeScope(jjtn001, true);
            }
          }
/*@egen*/       
	{
		obj.canRepeatNodes = false;
	}
	|/*@bgen(jjtree) SimpleCycle */
          {
            SimpleNode jjtn002 = new SimpleNode(JJTSIMPLECYCLE);
            boolean jjtc002 = true;
            jjtree.openNodeScope(jjtn002);
          }
          try {
/*@egen*/ <SIMPLECYCLE>/*@bgen(jjtree)*/
          } finally {
            if (jjtc002) {
              jjtree.closeNodeScope(jjtn002, true);
            }
          }
/*@egen*/             
	{
		obj.canRepeatNodes = true;
	}
	)
}

void CycleCriteria(Cycle obj)      : {} {
	Length(obj) Property(obj) (RestrictionPath(obj))?
}

void Length(Cycle obj)      : {Token t;} {
	<MINLENGTH> t=<INT>
	{
		obj.minLength = Integer.parseInt(t.image);
	}
}