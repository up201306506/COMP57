/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. parsernav.jj */
/*@egen*/options {
	LOOKAHEAD=1;
}

PARSER_BEGIN(ParserNav)

import java.io.*;
import java.util.*;

public class ParserNav/*@bgen(jjtree)*/implements ParserNavTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTParserNavState jjtree = new JJTParserNavState();

/*@egen*/
	
	public static LinkedList<Path> querries = new LinkedList<Path>();
	
	public static void main(String args[]) throws ParseException, FileNotFoundException {
		
		// checks args
		if(args.length != 1){
			System.out.println("Incorrect arguments, correct use:");
			System.out.println("ParserNav <path of file to be compiled>");
			System.exit(-1);
		}
		
		FileInputStream fis = new FileInputStream(new File(args[0]));
		
		ParserNav parserNav = new ParserNav(fis);
		SimpleNode root = parserNav.ParseExpression();
		
		System.out.println("\n\nAST:\n");
		root.dump("");
		System.out.println("\n--------");
		
		exportToFile(args[0]);
	}
	
	public static void exportToFile(String filePath){
		System.out.println("Exporting To File");
		
		int index = filePath.lastIndexOf(".");
		String exportFile = filePath.substring(0, index);
		exportFile += "_output";
		exportFile += filePath.substring(index, filePath.length());
		
		while(!querries.isEmpty()){
			System.out.println((To) querries.remove());
		}
	}
}

PARSER_END(ParserNav)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

TOKEN :
{
	< COMMA: "," >
|	< SEMICOLON: ( ";" ) >
|	< SRC: ( "src" ) >
|	< DEST: ( "dest" ) >
|	< FIND: ( "find" ) >
|	< CYCLE: ( "cycle" ) >
|	< SIMPLECYCLE: ( "simplecycle" ) >
|	< NOT: ( "not" ) >
|	< PASS: ( "pass" ) >
|	< LENGTH: ( "length" ) >
|	< NEAREST: ( "nearest" ) >
|	< MAXIMIZE: ( "maximize" ) >
|	< MINIMIZE: ( "minimize" ) >
|	< VAR: ["A"-"Z","a"-"z"](["0"-"9","A"-"Z","a"-"z"])* >
|	< INT: (["0"-"9"])+>
}

SimpleNode ParseExpression()       : {/*@bgen(jjtree) Parse */
                                      SimpleNode jjtn000 = new SimpleNode(JJTPARSE);
                                      boolean jjtc000 = true;
                                      jjtree.openNodeScope(jjtn000);
/*@egen*/Path obj;} {/*@bgen(jjtree) Parse */
        try {
/*@egen*/
	obj=StartNode() <SEMICOLON>
	{
		querries.add(obj);
	}
	( <EOF> | ParseExpression() )/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		return jjtn000;
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

Path StartNode()      : {Token t; Path obj;} {
	<SRC> t=<VAR>
	obj=Path(t)
	{
		return obj;
	}
}

To Path(Token t)    : {/*@bgen(jjtree) To */
                       SimpleNode jjtn000 = new SimpleNode(JJTTO);
                       boolean jjtc000 = true;
                       jjtree.openNodeScope(jjtn000);
/*@egen*/To obj;} {/*@bgen(jjtree) To */
        try {
/*@egen*/
	{
		obj = new To();
		obj.sourceNodeName = t.image;
	}
	DestNode(obj) PathCriteria(obj)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		return obj;
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void DestNode(To obj)      : {Token t;} {
	<DEST> t=<VAR>
	{
		obj.destNodeName = t.image;
	}
}

void PathCriteria(To obj)      : {} {
	OptimalCriteria(obj) (RestrictionPath(obj))?
}

void OptimalCriteria(To obj)      : {} {
	( <MINIMIZE>
	{
		obj.toMinimize = true;
	}
	| <MAXIMIZE>
	{
		obj.toMinimize = false;
	}
	) Property(obj) 
}

void Property(To obj)      : {Token t;} {
	t=<VAR>
	{
		obj.attributeFocus = t.image;
	}
}

void RestrictionPath(To obj)      : {} {
	{
		obj.usePassingRestriction = true;
	}
	(<NOT>
	{
		obj.toPass = false;
	}
	)? <PASS>	RestrictionPathParam(obj)
}

void RestrictionPathParam(To obj)      : {Token t;} {
	t=<VAR>
	{
		obj.restrictionPathNodes.add(t.image);
	}
	(<COMMA> RestrictionPathParam(obj))?
}